/* Generated By:JavaCC: Do not edit this line. JavaCharStream.java Version 3.0 */

namespace OGNL.Parser;

/**
 * An implementation of interface CharStream, where the stream is assumed
 * to contain only ASCII characters (with java-like Unicode escape
 * processing).
 */
public class JavaCharStream {
    private static int HexVal(char c)
    {
        return c switch {
            '0' => 0,
            '1' => 1,
            '2' => 2,
            '3' => 3,
            '4' => 4,
            '5' => 5,
            '6' => 6,
            '7' => 7,
            '8' => 8,
            '9' => 9,
            'a' or 'A' => 10,
            'b' or 'B' => 11,
            'c' or 'C' => 12,
            'd' or 'D' => 13,
            'e' or 'E' => 14,
            'f' or 'F' => 15,
            _ => throw new IOException() // Should never come here
        };
    }

    private readonly TextReader inputStream;

    private readonly char[] nextCharBuf;

    private int bufPos = -1;

    private int bufSize;

    private int available;

    private int tokenBegin;

    private int[] bufLine;

    private int[] bufColumn;

    private int column;

    private int line;

    private bool prevCharIsCr;

    private bool prevCharIsLf;

    private char[] buffer;

    private int maxNextCharInd;

    private int nextCharInd = -1;

    private int inBuf;

    private void ExpandBuff(bool wrapAround)
    {
        var newBuffer = new char[bufSize + 2048];
        var newBufLine = new int[bufSize + 2048];
        var newBufColumn = new int[bufSize + 2048];

        try {
            if (wrapAround) {
                Array.Copy(buffer, tokenBegin, newBuffer, 0, bufSize - tokenBegin);
                Array.Copy(buffer, 0, newBuffer,
                    bufSize - tokenBegin, bufPos);
                buffer = newBuffer;

                Array.Copy(bufLine, tokenBegin, newBufLine, 0, bufSize - tokenBegin);
                Array.Copy(bufLine, 0, newBufLine, bufSize - tokenBegin, bufPos);
                bufLine = newBufLine;

                Array.Copy(bufColumn, tokenBegin, newBufColumn, 0, bufSize - tokenBegin);
                Array.Copy(bufColumn, 0, newBufColumn, bufSize - tokenBegin, bufPos);
                bufColumn = newBufColumn;

                bufPos += bufSize - tokenBegin;
            } else {
                Array.Copy(buffer, tokenBegin, newBuffer, 0, bufSize - tokenBegin);
                buffer = newBuffer;

                Array.Copy(bufLine, tokenBegin, newBufLine, 0, bufSize - tokenBegin);
                bufLine = newBufLine;

                Array.Copy(bufColumn, tokenBegin, newBufColumn, 0, bufSize - tokenBegin);
                bufColumn = newBufColumn;

                bufPos -= tokenBegin;
            }
        } catch (Exception t) {
            throw new Exception(t.Message);
        }

        available = bufSize += 2048;
        tokenBegin = 0;
    }

    private void FillBuff()
    {
        if (maxNextCharInd == 4096)
            maxNextCharInd = nextCharInd = 0;

        try {
            try {
                // .NET will return 0 instead of 1 in java.
                var i = inputStream.Read(nextCharBuf, maxNextCharInd,
                    4096 - maxNextCharInd);

                if (i <= 0 /* == -1 */) {
                    inputStream.Close();

                    throw new IOException();
                }

                maxNextCharInd += i;
            } catch (ObjectDisposedException) {
                throw new IOException("Stream Closed!");
            }
        } catch (IOException) {
            if (bufPos != 0) {
                --bufPos;
                Backup(0);
            } else {
                bufLine[bufPos] = line;
                bufColumn[bufPos] = column;
            }

            throw;
        }
    }

    private char ReadByte()
    {
        if (++nextCharInd >= maxNextCharInd)
            FillBuff();

        return nextCharBuf[nextCharInd];
    }

    public char BeginToken()
    {
        if (inBuf > 0) {
            --inBuf;

            if (++bufPos == bufSize)
                bufPos = 0;

            tokenBegin = bufPos;

            return buffer[bufPos];
        }

        tokenBegin = 0;
        bufPos = -1;

        return ReadChar();
    }

    private void AdjustBuffSize()
    {
        if (available == bufSize) {
            if (tokenBegin > 2048) {
                bufPos = 0;
                available = tokenBegin;
            } else
                ExpandBuff(false);
        } else if (available > tokenBegin)
            available = bufSize;
        else if (tokenBegin - available < 2048)
            ExpandBuff(true);
        else
            available = tokenBegin;
    }

    private void UpdateLineColumn(char c)
    {
        column++;

        if (prevCharIsLf) {
            prevCharIsLf = false;
            line += column = 1;
        } else if (prevCharIsCr) {
            prevCharIsCr = false;

            if (c == '\n')
                prevCharIsLf = true;
            else
                line += column = 1;
        }

        switch (c) {
            case '\r':
                prevCharIsCr = true;

                break;
            case '\n':
                prevCharIsLf = true;

                break;
            case '\t':
                column--;
                column += 8 - (column & 7);

                break;
        }

        bufLine[bufPos] = line;
        bufColumn[bufPos] = column;
    }

    public char ReadChar()
    {
        if (inBuf > 0) {
            --inBuf;

            if (++bufPos == bufSize)
                bufPos = 0;

            return buffer[bufPos];
        }

        char c;

        if (++bufPos == available)
            AdjustBuffSize();

        if ((buffer[bufPos] = c = ReadByte()) == '\\') {
            UpdateLineColumn(c);

            var backSlashCnt = 1;

            // Read all the backslashes
            for (;;) {
                if (++bufPos == available)
                    AdjustBuffSize();

                try {
                    if ((buffer[bufPos] = c = ReadByte()) != '\\') {
                        UpdateLineColumn(c);

                        // found a non-backslash char.
                        if (c == 'u' && (backSlashCnt & 1) == 1) {
                            if (--bufPos < 0)
                                bufPos = bufSize - 1;

                            break;
                        }

                        Backup(backSlashCnt);

                        return '\\';
                    }
                } catch (IOException) {
                    if (backSlashCnt > 1)
                        Backup(backSlashCnt);

                    return '\\';
                }

                UpdateLineColumn(c);
                backSlashCnt++;
            }

            // Here, we have seen an odd number of backslash's followed by a 'u'
            try {
                while ((c = ReadByte()) == 'u')
                    ++column;

                buffer[bufPos] = c = (char)(HexVal(c) << 12 |
                    HexVal(ReadByte()) << 8 |
                    HexVal(ReadByte()) << 4 |
                    HexVal(ReadByte()));

                column += 4;
            } catch (IOException) {
                throw new Exception(
                    $"Invalid escape character at line {line} column {column}.");
            }

            if (backSlashCnt == 1)
                return c;

            Backup(backSlashCnt - 1);

            return '\\';
        }

        UpdateLineColumn(c);

        return c;
    }

    public int GetEndColumn()
    {
        return bufColumn[bufPos];
    }

    public int GetEndLine()
    {
        return bufLine[bufPos];
    }

    public int GetBeginColumn()
    {
        return bufColumn[tokenBegin];
    }

    public int GetBeginLine()
    {
        return bufLine[tokenBegin];
    }

    public void Backup(int amount)
    {
        inBuf += amount;
        if ((bufPos -= amount) < 0)
            bufPos += bufSize;
    }

    private JavaCharStream(TextReader dStream, int startLine,
        int startColumn, int bufferSize)
    {
        inputStream = dStream;
        line = startLine;
        column = startColumn - 1;

        available = bufSize = bufferSize;
        buffer = new char[bufferSize];
        bufLine = new int[bufferSize];
        bufColumn = new int[bufferSize];
        nextCharBuf = new char[4096];
    }

    public JavaCharStream(TextReader dStream, int startLine,
        int startColumn) : this(dStream, startLine, startColumn, 4096)
    {
    }

    public string GetImage()
    {
        if (bufPos >= tokenBegin)
            return new string(buffer, tokenBegin, bufPos - tokenBegin + 1);

        return new string(buffer, tokenBegin, bufSize - tokenBegin) +
            new string(buffer, 0, bufPos + 1);
    }

    public char[] GetSuffix(int len)
    {
        var ret = new char[len];

        if (bufPos + 1 >= len)
            Array.Copy(buffer, bufPos - len + 1, ret, 0, len);
        else {
            Array.Copy(buffer, bufSize - (len - bufPos - 1), ret, 0,
                len - bufPos - 1);
            Array.Copy(buffer, 0, ret, len - bufPos - 1, bufPos + 1);
        }

        return ret;
    }
}
