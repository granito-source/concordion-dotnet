/* Generated By:JavaCC: Do not edit this line. JavaCharStream.java Version 3.0 */

namespace OGNL.Parser;

/**
 * An implementation of interface CharStream, where the stream is assumed to
 * contain only ASCII characters (with java-like unicode escape processing).
 */
public class JavaCharStream {
    private static int Hexval(char c) // throws java.io.IOException
    {
        return c switch {
            '0' => 0,
            '1' => 1,
            '2' => 2,
            '3' => 3,
            '4' => 4,
            '5' => 5,
            '6' => 6,
            '7' => 7,
            '8' => 8,
            '9' => 9,
            'a' or 'A' => 10,
            'b' or 'B' => 11,
            'c' or 'C' => 12,
            'd' or 'D' => 13,
            'e' or 'E' => 14,
            'f' or 'F' => 15,
            _ => throw new IOException() // Should never come here
        };
    }

    private int bufpos = -1;

    private int bufsize;

    private int available;

    private int tokenBegin;

    private int[] bufline;

    private int[] bufcolumn;

    private int column = 0;

    private int line = 1;

    private bool prevCharIsCr = false;

    private bool prevCharIsLf = false;

    private TextReader inputStream;

    private char[] nextCharBuf;

    private char[] buffer;

    private int maxNextCharInd = 0;

    private int nextCharInd = -1;

    private int inBuf = 0;

    private void ExpandBuff(bool wrapAround)
    {
        var newbuffer = new char[bufsize + 2048];
        var newbufline = new int[bufsize + 2048];
        var newbufcolumn = new int[bufsize + 2048];

        try {
            if (wrapAround) {
                Array.Copy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
                Array.Copy(buffer, 0, newbuffer,
                    bufsize - tokenBegin, bufpos);
                buffer = newbuffer;

                Array.Copy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
                Array.Copy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
                bufline = newbufline;

                Array.Copy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
                Array.Copy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
                bufcolumn = newbufcolumn;

                bufpos += bufsize - tokenBegin;
            } else {
                Array.Copy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
                buffer = newbuffer;

                Array.Copy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
                bufline = newbufline;

                Array.Copy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
                bufcolumn = newbufcolumn;

                bufpos -= tokenBegin;
            }
        } catch (Exception t) {
            throw new Exception(t.Message);
        }

        available = bufsize += 2048;
        tokenBegin = 0;
    }

    private void FillBuff()
    {
        int i;

        if (maxNextCharInd == 4096)
            maxNextCharInd = nextCharInd = 0;

        try {
            try {
                // .Net will return 0 instead of 1 in java.
                if ((i = inputStream.Read(nextCharBuf, maxNextCharInd,
                        4096 - maxNextCharInd)) <= 0 /* == -1 */) {
                    inputStream.Close();

                    throw new IOException();
                }

                maxNextCharInd += i;
            } catch (ObjectDisposedException) {
                throw new IOException("Stream Closed!");
            }
        } catch (IOException) {
            if (bufpos != 0) {
                --bufpos;
                Backup(0);
            } else {
                bufline[bufpos] = line;
                bufcolumn[bufpos] = column;
            }

            throw;
        }
    }

    private char ReadByte()
    {
        if (++nextCharInd >= maxNextCharInd)
            FillBuff();

        return nextCharBuf[nextCharInd];
    }

    public char BeginToken()
    {
        if (inBuf > 0) {
            --inBuf;

            if (++bufpos == bufsize)
                bufpos = 0;

            tokenBegin = bufpos;

            return buffer[bufpos];
        }

        tokenBegin = 0;
        bufpos = -1;

        return ReadChar();
    }

    private void AdjustBuffSize()
    {
        if (available == bufsize) {
            if (tokenBegin > 2048) {
                bufpos = 0;
                available = tokenBegin;
            } else
                ExpandBuff(false);
        } else if (available > tokenBegin)
            available = bufsize;
        else if (tokenBegin - available < 2048)
            ExpandBuff(true);
        else
            available = tokenBegin;
    }

    private void UpdateLineColumn(char c)
    {
        column++;

        if (prevCharIsLf) {
            prevCharIsLf = false;
            line += column = 1;
        } else if (prevCharIsCr) {
            prevCharIsCr = false;

            if (c == '\n') {
                prevCharIsLf = true;
            } else
                line += column = 1;
        }

        switch (c) {
            case '\r':
                prevCharIsCr = true;

                break;
            case '\n':
                prevCharIsLf = true;

                break;
            case '\t':
                column--;
                column += 8 - (column & 7);

                break;
        }

        bufline[bufpos] = line;
        bufcolumn[bufpos] = column;
    }

    public char ReadChar()
    {
        if (inBuf > 0) {
            --inBuf;

            if (++bufpos == bufsize)
                bufpos = 0;

            return buffer[bufpos];
        }

        char c;

        if (++bufpos == available)
            AdjustBuffSize();

        if ((buffer[bufpos] = c = ReadByte()) == '\\') {
            UpdateLineColumn(c);

            var backSlashCnt = 1;

            // Read all the backslashes
            for (;;) {
                if (++bufpos == available)
                    AdjustBuffSize();

                try {
                    if ((buffer[bufpos] = c = ReadByte()) != '\\') {
                        UpdateLineColumn(c);

                        // found a non-backslash char.
                        if (c == 'u' && (backSlashCnt & 1) == 1) {
                            if (--bufpos < 0)
                                bufpos = bufsize - 1;

                            break;
                        }

                        Backup(backSlashCnt);

                        return '\\';
                    }
                } catch (IOException) {
                    if (backSlashCnt > 1)
                        Backup(backSlashCnt);

                    return '\\';
                }

                UpdateLineColumn(c);
                backSlashCnt++;
            }

            // Here, we have seen an odd number of backslash's followed by a 'u'
            try {
                while ((c = ReadByte()) == 'u')
                    ++column;

                buffer[bufpos] = c = (char)(Hexval(c) << 12 |
                    Hexval(ReadByte()) << 8 |
                    Hexval(ReadByte()) << 4 |
                    Hexval(ReadByte()));

                column += 4;
            } catch (IOException e) {
                throw new Exception("Invalid escape character at line " + line +
                    " column " + column + ".");
            }

            if (backSlashCnt == 1)
                return c;

            Backup(backSlashCnt - 1);

            return '\\';
        }

        UpdateLineColumn(c);

        return c;
    }

    public int GetEndColumn()
    {
        return bufcolumn[bufpos];
    }

    public int GetEndLine()
    {
        return bufline[bufpos];
    }

    public int GetBeginColumn()
    {
        return bufcolumn[tokenBegin];
    }

    public int GetBeginLine()
    {
        return bufline[tokenBegin];
    }

    public void Backup(int amount)
    {
        inBuf += amount;
        if ((bufpos -= amount) < 0)
            bufpos += bufsize;
    }

    private JavaCharStream(TextReader dstream,
        int startline, int startcolumn, int buffersize)
    {
        inputStream = dstream;
        line = startline;
        column = startcolumn - 1;

        available = bufsize = buffersize;
        buffer = new char[buffersize];
        bufline = new int[buffersize];
        bufcolumn = new int[buffersize];
        nextCharBuf = new char[4096];
    }

    public JavaCharStream(TextReader dstream,
        int startline, int startcolumn)
        : this(dstream, startline, startcolumn, 4096)
    {
    }

    private void ReInit(TextReader dstream,
        int startline, int startcolumn, int buffersize)
    {
        inputStream = dstream;
        line = startline;
        column = startcolumn - 1;

        if (buffer == null || buffersize != buffer.Length) {
            available = bufsize = buffersize;
            buffer = new char[buffersize];
            bufline = new int[buffersize];
            bufcolumn = new int[buffersize];
            nextCharBuf = new char[4096];
        }

        prevCharIsLf = prevCharIsCr = false;
        tokenBegin = inBuf = maxNextCharInd = 0;
        nextCharInd = bufpos = -1;
    }

    public void ReInit(TextReader dstream,
        int startline, int startcolumn)
    {
        ReInit(dstream, startline, startcolumn, 4096);
    }

    private JavaCharStream(Stream dstream, int startline,
        int startcolumn, int buffersize) :
        this(new StreamReader(dstream), startline, startcolumn, 4096)
    {
    }

    public JavaCharStream(Stream dstream, int startline,
        int startcolumn)
        : this(dstream, startline, startcolumn, 4096)
    {
    }

    private void ReInit(Stream dstream, int startline,
        int startcolumn, int buffersize)
    {
        ReInit(new StreamReader(dstream), startline, startcolumn, 4096);
    }

    public void ReInit(Stream dstream, int startline,
        int startcolumn)
    {
        ReInit(dstream, startline, startcolumn, 4096);
    }

    public string GetImage()
    {
        if (bufpos >= tokenBegin)
            return new string(buffer, tokenBegin, bufpos - tokenBegin + 1);

        return new string(buffer, tokenBegin, bufsize - tokenBegin) +
            new string(buffer, 0, bufpos + 1);
    }

    public char[] GetSuffix(int len)
    {
        var ret = new char[len];

        if (bufpos + 1 >= len)
            Array.Copy(buffer, bufpos - len + 1, ret, 0, len);
        else {
            Array.Copy(buffer, bufsize - (len - bufpos - 1), ret, 0,
                len - bufpos - 1);
            Array.Copy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
        }

        return ret;
    }
}
